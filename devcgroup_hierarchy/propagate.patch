---
 security/device_cgroup.c |  196 ++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 177 insertions(+), 19 deletions(-)

Index: github/security/device_cgroup.c
===================================================================
--- github.orig/security/device_cgroup.c	2012-10-16 14:00:56.600160676 -0400
+++ github/security/device_cgroup.c	2012-10-16 16:21:22.607072222 -0400
@@ -194,6 +194,16 @@
 	return rc;
 }
 
+static void __dev_exception_clean(struct list_head *exceptions)
+{
+	struct dev_exception_item *ex, *tmp;
+
+	list_for_each_entry_safe(ex, tmp, exceptions, list) {
+		list_del(&ex->list);
+		kfree(ex);
+	}
+}
+
 /**
  * dev_exception_clean - frees all entries of the exception list
  * @dev_cgroup: dev_cgroup with the exception list to be cleaned
@@ -202,17 +212,8 @@
  */
 static void dev_exception_clean(struct dev_cgroup *dev_cgroup)
 {
-	struct dev_exception_item *ex, *tmp;
-
-	list_for_each_entry_safe(ex, tmp, &dev_cgroup->exceptions, list) {
-		list_del(&ex->list);
-		kfree(ex);
-	}
-	list_for_each_entry_safe(ex, tmp, &dev_cgroup->local.exceptions,
-				 list) {
-		list_del(&ex->list);
-		kfree(ex);
-	}
+	__dev_exception_clean(&dev_cgroup->exceptions);
+	__dev_exception_clean(&dev_cgroup->local.exceptions);
 }
 
 /*
@@ -445,12 +446,147 @@
  */
 static int may_allow_all(struct dev_cgroup *devcg)
 {
-	struct cgroup *pcg = childcg->css.cgroup->parent;
+	struct cgroup *pcg = devcg->css.cgroup->parent;
+	struct dev_cgroup *parent = cgroup_to_devcgroup(pcg);
+
+	return parent->behavior == DEVCG_DEFAULT_ALLOW;
+}
+
+/**
+ * __revalidate_exceptions - walks through the exception list and revalidates
+ *			     the exceptions based on parents' behavior and
+ *			     exceptions. Called with devcgroup_mutex held.
+ * @devcg: cgroup which exceptions will be checked
+ */
+static void __revalidate_exceptions(struct dev_cgroup *devcg)
+{
+	struct cgroup *pcg = devcg->css.cgroup->parent;
 	struct dev_cgroup *parent = cgroup_to_devcgroup(pcg);
+	struct dev_exception_item *ex;
+	struct list_head *this, *tmp;
 
-	return parent->behavior == DEVCG_ALLOW;
+	list_for_each_safe(this, tmp, &devcg->local.exceptions) {
+		ex = container_of(this, struct dev_exception_item, list);
+		if (!may_access(parent, ex)) {
+			list_del(this);
+			kfree(ex);
+		}
+	}
 }
 
+/* called with devcgroup_mutex held, by walk_cgroup_tree_from() */
+static int __propagate_behavior(struct cgroup *cgroup, void *data)
+{
+	struct cgroup *pcg = cgroup->parent;
+	struct dev_cgroup *root, *parent = cgroup_to_devcgroup(pcg);
+	struct dev_cgroup *devcg = cgroup_to_devcgroup(cgroup);
+	int rc;
+
+	root = data;
+	if (devcg == root)
+		return 0;
+
+	/* first copy parent's state */
+	devcg->behavior = parent->behavior;
+	__dev_exception_clean(&devcg->exceptions);
+	rc = dev_exceptions_copy(&devcg->exceptions, &parent->exceptions);
+	if (rc) {
+		devcg->behavior = DEVCG_DEFAULT_DENY;
+		return rc;
+	}
+
+	/* now to evaluate local behavior and exceptions */
+	if (devcg->local.behavior == DEVCG_DEFAULT_NONE)
+		__dev_exception_clean(&devcg->local.exceptions);
+	else if (devcg->behavior != devcg->local.behavior) {
+		/* if the parent changed to DENY, ALLOW is not possible */
+		if (devcg->local.behavior == DEVCG_DEFAULT_ALLOW) {
+			devcg->local.behavior = DEVCG_DEFAULT_NONE;
+			__dev_exception_clean(&devcg->local.exceptions);
+		} else {
+			devcg->behavior = DEVCG_DEFAULT_DENY;
+			__revalidate_exceptions(devcg);
+			rc = dev_exceptions_copy(&devcg->exceptions,
+						 &devcg->local.exceptions);
+		}
+	} else {
+		/*
+		 * parent's behavior changed to the local setting, we can
+		 * reuse the exceptions
+		 */
+		__revalidate_exceptions(devcg);
+		rc = dev_exceptions_copy(&devcg->exceptions,
+					 &devcg->local.exceptions);
+	}
+
+	return rc;
+}
+
+/* called with devcroup_mutex held */
+static int __propagate_exception(struct cgroup *cgroup, void *data)
+{
+	struct cgroup *pcg = cgroup->parent;
+	struct dev_cgroup *root, *parent = cgroup_to_devcgroup(pcg);
+	struct dev_cgroup *devcg = cgroup_to_devcgroup(cgroup);
+	int rc;
+
+	root = data;
+	if (devcg == root)
+		return 0;
+
+	/* first copy parent's state */
+	devcg->behavior = parent->behavior;
+	__dev_exception_clean(&devcg->exceptions);
+	rc = dev_exceptions_copy(&devcg->exceptions, &parent->exceptions);
+	if (rc) {
+		devcg->behavior = DEVCG_DEFAULT_DENY;
+		return rc;
+	}
+
+	if (devcg->behavior != parent->behavior) {
+		/* we never give more permissions to the child */
+		WARN_ONCE(devcg->behavior == DEVCG_DEFAULT_ALLOW,
+			  "devcg: parent/child behavior is inconsistent");
+		__revalidate_exceptions(devcg);
+	} else {
+		__revalidate_exceptions(devcg);
+	}
+
+	rc = dev_exceptions_copy(&devcg->exceptions,
+				 &devcg->local.exceptions);
+
+	return rc;
+}
+
+/**
+ * propagate_behavior - propagates a change in the behavior to the children
+ * @devcg: device cgroup that changed behavior
+ *
+ * returns: 0 in case of success, != 0 in case of error
+ */
+static int propagate_behavior(struct dev_cgroup *devcg)
+{
+	struct cgroup *root = devcg->css.cgroup;
+
+	return walk_cgroup_tree_from(root, __propagate_behavior,
+				     cgroup_visitor_nop, devcg);
+}
+
+/**
+ * propagate_exception - propagates a new exception to the children
+ * @devcg: device cgroup that added a new exception
+ *
+ * returns: 0 in case of success, != 0 in case of error
+ */
+static int propagate_exception(struct dev_cgroup *devcg)
+{
+	struct cgroup *root = devcg->css.cgroup;
+
+	return walk_cgroup_tree_from(root, __propagate_exception,
+				     cgroup_visitor_nop, devcg);
+}
+
+
 /*
  * Modify the exception list using allow/deny rules.
  * CAP_SYS_ADMIN is needed for this.  It's at least separate from CAP_MKNOD
@@ -493,16 +629,18 @@
 				return rc;
 			devcgroup->behavior = DEVCG_DEFAULT_ALLOW;
 			devcgroup->local.behavior = DEVCG_DEFAULT_ALLOW;
+			rc = propagate_behavior(devcgroup);
 			break;
 		case DEVCG_DENY:
 			dev_exception_clean(devcgroup);
 			devcgroup->behavior = DEVCG_DEFAULT_DENY;
 			devcgroup->local.behavior = DEVCG_DEFAULT_DENY;
+			rc = propagate_behavior(devcgroup);
 			break;
 		default:
-			return -EINVAL;
+			rc = -EINVAL;
 		}
-		return 0;
+		return rc;
 	case 'b':
 		ex.type = DEV_BLOCK;
 		break;
@@ -590,7 +728,10 @@
 			dev_exception_rm(devcgroup, &ex);
 			return 0;
 		}
-		return dev_exception_add(devcgroup, &ex);
+		rc = dev_exception_add(devcgroup, &ex);
+		if (rc)
+			return rc;
+		break;
 	case DEVCG_DENY:
 		/*
 		 * If the default policy is to deny by default, try to remove
@@ -601,11 +742,16 @@
 			dev_exception_rm(devcgroup, &ex);
 			return 0;
 		}
-		return dev_exception_add(devcgroup, &ex);
+		rc = dev_exception_add(devcgroup, &ex);
+		if (rc)
+			return rc;
+		/* we only propagate new restrictions */
+		rc = propagate_exception(devcgroup);
+		break;
 	default:
-		return -EINVAL;
+		rc = -EINVAL;
 	}
-	return 0;
+	return rc;
 }
 
 static int devcgroup_access_write(struct cgroup *cgrp, struct cftype *cft,
